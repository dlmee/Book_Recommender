---
title: "Book Recommender"
output: html_notebook
---

### Initial Exploration of Data

```{r}
library(reshape2)
library(dplyr)
setwd("/home/dlmee/Info523/Book_Recommender")
getwd()
result <- read.csv(file = "Books.csv")
ratings <- read.csv(file = "Ratings.csv")
#reviews <- read.csv(file = "Users.csv") I don't think we'll end up using this. 

search <- ratings[ratings$Book.Rating != '0',]

#Get rid of rows that occur less than 60 times. This is making sure that we're only getting reviewers who consistently review. 
df2 <- search %>%
  group_by(User.ID) %>%
  filter(n() >= 60)

# Find everyone who rates at least one a ten, make it distinct
df3 <- df2 %>%
  filter(grepl('10', Book.Rating)) %>%
  distinct(User.ID, .keep_all = TRUE)

# Find users who rated at least 4 books a 10
features <- df3 %>%
  group_by(ISBN) %>%
  filter(n() >= 4) %>%
  distinct(ISBN, .keep_all = TRUE)

superusers <- pull(features, User.ID)
superbooks <- pull(features, ISBN)

# Just in case we're curious
curious <- result[result$ISBN %in% superbooks,]





#Now to build the features function. 
featselect <- function(superusers, ratings){
  features <- list()
  for (super in superusers){
    step <- ratings %>%
      filter(grepl(super, User.ID))
    feature <- list()
    for (row in 1:nrow(step)){
      allusers <- ratings %>%
        filter(grepl(step[row,2], ISBN)) %>%
        filter(grepl(step[row,3], Book.Rating)) %>%
        pull(User.ID)
      #print(c("Finished a run:", row, length(allusers)))
      feature <- c(feature, list(allusers))
    }
  feature <- unlist(feature, recursive = TRUE)
  feature <- unique(feature)
  print(c("finished a feature:", length(feature)))
  features <- c(features, list(feature))
  }
  return (features)
}

features <- featselect(superusers, search)

# Let's write that to a csv
capture.output(features, file = "features.csv")


#Let's see how much these two intersect, I'm pretty happy with this. 85 overlap between collectively 1600 in a pair, fairly distinct.
#If we wanted we could remove these users...I'll leave them for now. 
for (i in 1:length(features)){
  base <- features[[i]]
  for (j in 1:length(features)){
    if (i < j){
      reach <- features[[j]]
      br <- intersect(base, reach)
      brfinal <- paste("Comparing", i, "with", j, "matches =", length(br), sep = ' ')
      write(brfinal, file = "similarity.txt", append = TRUE)
    }
  write(" ", "similarity.txt", append = TRUE)
  }
}


#Now with these lists of users, we simply need to go one step further, and add their scores to a row, so we have pairs of ISBN and cumulative scores. These will be one step prior to our true features

# We'll need a df with a single column that has all items. 
items <- result %>%
  select(ISBN)

#Let's transform this into a function.

feat2item <- function(features, items, ratings){
  for (i in seq_along(features)){
    title <- paste("feature", i, sep = '')
    items[[title]] <- 1
  draw <- ratings %>%
    filter(User.ID %in% features[[i]])
  for (row in 1:nrow(draw)){
  cbook <- draw[row,2]
  cscore <-draw[row,3]
  original <- items[items$ISBN == cbook,] %>%
    pull(title)
  items[title][items['ISBN'] == cbook] <- cscore + original
    }
  }
  return (items)
}

itemfeatures <- feat2item(features, items, search)

#write.csv(itemfeatures, file = "itemfeatures.csv")

#Now to build feat2user. Just like with above, I need to create a user dataframe with a single column. 

users <- ratings %>%
  distinct(User.ID) %>%
  select(User.ID)

#a little helper function for the comparison. 
all.eqNum <- function(x,y) as.numeric(sub(".*:", '', all.equal(x,y))) # Found this code snippet on rdocumentation.org, awesome! Thanks!

#Interestingly whereas with feat2item we went column, by column, here it's going to be row by row. We treat a user entirely, then move on. How interesting!

feat2user <- function(features, users, ratings){
  for (i in seq_along(features)){
    title <- paste("feature", i, sep = '')
    users[[title]] <- .001
  }
  # For user
  for (row in 1:nrow(users)){
    #Grab that users reviews
    interest <- ratings %>%
      filter(User.ID == users[row,1])
    
    for (i in seq_along(features)){
      #iterate through feature
      #Remove current user from feature if present
      cfeat <- features[[i]] 
      cfeat <- cfeat[cfeat != users[row,1]]
      
      #Select all ratings from those users.
      supint <- ratings %>%
        filter(User.ID %in% cfeat)
      
      #Intersect those by book title then multiply by rating
      relationship <- inner_join(interest, supint, by = "ISBN") 
      if (dim(relationship)[1] != 0){
        users[row, i+1] <- all.eqNum(relationship$Book.Rating.x, relationship$Book.Rating.y)
      }
      
      #Take that result and add as the feature value to the user.
      }
    }
  # For feature
  # Compare user against feature (i.e. superuser)
  # How similar are the ratings between the user and the superuser. 
  return (users)
}

sampler <- users %>%
  slice_sample(n =5)
nusers <- feat2user(features, sampler, search)

#Finally we need to apply this to USER and ITEM, such that every user has each feature score, and every item has each feature score. This will be our true feature matrix.



```
### Practice
These are some aspects of R that I needed to understand in order to succeed on this project
```{r}
# lists

#This is just to practice with lists a bit
  telist <- list()
  telist <- c(telist, list(superusers))
  telist <- c(telist, list(superbooks))
  teunlist <- unlist(telist, recursive = TRUE)

# Modifying elements of a dataframe

  level2['currentfeat'][level2['ISBN'] == '0195153448'] <- 24
  find <- level2[level2$ISBN == '0195153448',] %>%
    pull(currentfeat)

#Interacting with pipes and dplyr

  # An example of select and mutate
  items <- result %>%
    select(ISBN) %>%
    mutate(
      currentfeat = 0
    )


  #An exmaple of filter and %in%
  draw <- search %>%
      filter(User.ID %in% tester[[1]])
  
#Using the intersect function
  crosscut <- intersect(features[[1]], features[[7]])
  
  dft1 <- ratings %>%
    slice_sample(n = 10)
  dft2 <- ratings %>%
    slice_sample(n = 10)
  ccdf <- inner_join(dft1, dft2, by = "ISBN") %>%
    filter(Book.Rating.x == Book.Rating.y)
    
  mdif <- all.equal.numeric(ccdf$Book.Rating.x, ccdf$Book.Rating.y)
  all.eqNum <- function(x,y) as.numeric(sub(".*:", '', all.equal(x,y))) # Found this code snippet on rdocumentation.org, awesome! Thanks!
  mdif <- all.eqNum(ccdf$Book.Rating.x, ccdf$Book.Rating.y)
#Using the paste function
 brfinal <- paste("Comparing", i, "with", j, "matches =", length(br), sep = ' ')
```


